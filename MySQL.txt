联合索引最左侧匹配原则
联合索引有一个最左侧匹配原则
最左匹配原则指的是，当使用联合索引进行查询时，MySQL会优先使用最左边的列进行匹配，然后再依次向右匹配。
所以 我们应该尽量把最常用的列放在联合索引的最左边，这样可以提高查询效率

索引的原理：就是把无序的数据变成有序的查询
1.  把创建了索引的列的内容进行排序。
2.  对排序结果生成倒排表。
3.  在倒排表内容上拼上数据地址链。
4.  在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

优势：
唯一索引可以保证数据库表中每一行数据的唯一性，索引可以加快数据查询速度，减少查询时间
劣势：
创建索引和维护索引要耗费时间，索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，给表中的数据进行增、删、改的时候，索引也要动态的维护。

MySQL索引的数据结构 Hash B+ InnoDB默认 B+
单条记录查询常见多 使用Hash 除此之外B+
B+树是一个平衡的多叉树 从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。
在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。
Hash索引 把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快

等值查询 Hash有绝对优势 前提是键值都是唯一的 如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据
如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索
哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）
哈希索引也不支持多列联合索引的最左匹配规则
B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。

索引设计原则 查询块 占用空间小
1.  适合索引的列是出现在where子句中的列，或者连接子句中指定的列。
2.  基数较小的表，索引效果较差，没有必要在此列建立索引
3.  使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配
4.  不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
5.  定义有外键的数据列一定要建立索引。
6.  更新频繁字段不适合创建索引。
7.  若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
8.  对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
9.  对于定义为text、image和bit的数据类型的列不要建立索引。

MySQL中B+树和B树的区别
1、非叶子节点数据不同：
B+树的非叶子节点的数据都在叶子节点中出现过，也就是叶子节点中的数据都在非叶子节点冗余一份。B树中非叶子节点中元素不会冗余。
B+树非叶子节点只存放指针，不存放数据，B树所有节点（叶子节点）都存放数据。
2、叶子节点数据不同：B+树叶子节点存放数据，B树所有节点（非叶子节）点存放数据。数据遍布整个树结构。
3、时间复杂度不同：由于B+树的数据都存在叶子节点，因此B+树的时间复杂度固定为o(log n)，而B树的数据分布在每个节点中，因此时间复杂度不固定，最好为o(1).
4、叶子节点连接不同：B+树的叶子节点通过有序的双向链表相连，B树叶子节点不相连。
5、区间查询效率不同：因为第4点的原因，所以B+树去范围查询效率更快，而B树范围查询比较慢。
因此，存在大量范围查询的场景，适合使用B+树
而对大量单个key查询的场景，可以考虑B树

MySQL中的锁类型有哪些？
共享锁(Share Lock)：
共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。

排他锁（Exclusive Lock）:
排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题.

表锁：
表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；
特点： 粒度大，加锁简单，容易冲突

行锁：
行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；
特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高。

记录锁(Record Lock)
记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。
精准条件命中，并且命中的条件字段是唯一索引
加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。

页锁：
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

间隙锁(Gap Lock）
属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。
间隙锁只会出现在REPEATABLE\_READ（可重复读)的事务级别中。
触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。
比如表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，5-7区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）。

临建锁(Next-Key Lock)：
也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住。
触发条件：范围查询并命中，查询命中了索引。
结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。

死锁的四个必要条件：
互斥条件，请求和保持条件，环路等待条件，不剥夺条件。

MySQL的约束有哪些？
NOT NULL: 约束字段的内容一定不能为NULL。
UNIQUE: 约束字段唯一性，一个表允许有多个Unique约束。
PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。
FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。
CHECK: 用于控制字段的值范围。保证字段值满足某一个条件。
DEFAULT：保存数据时，如果未指定该字段的值，则采用默认值

关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？
在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么？
1、是查询条件没有命中索引？
2、是load了不需要的数据列？
3、还是数据量太大？
所以优化也是针对这三个方向来的，
1、首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
2、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
3、如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

MySQL事务的基本特性和隔离级别
原子性:指的是一个事务中的操作要么全部成功，要么全部失败。
一致性: 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证。
隔离性:指的是一个事务的修改在最终提交前，对其他事务是不可见的。
持久性：指的是一旦事务提交，所做的修改就会永久保存到数据库中。

1）读未提交，可能会读到其他事务未提交的数据，也叫做脏读。
用户本来应该读取到id=1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age=20，这就是脏读。
2）读已提交，两次读取结果不一致，叫做不可重复读。
不可重复读解决了脏读的问题，他只会读取已经提交的事务。
用户开启事务读取id=1用户，查询到age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。
3）可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
4）串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争


MySQL中ACID靠什么保证的
（原子性）由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql。
（一致性）由其他三大特性保证、程序代码要保证业务上的一致性。
（隔离性）由MVCC来保证。
 (持久性) 由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作。宕机的时候可以从redo log恢复redolog的刷盘会在系统空闲时进行。

MVCC:多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务会看到自己特定版本的数据，版本链.


Union 和 Union All 区别：因为Union操作会对结果去重且排序，所以从速度来说， UNION ALL会更胜一筹。
主键使用自增ID还是UUID，为什么？
如果是单机的话，选择自增ID；如果是分布式系统，优先考虑UUID，但还是最好公司自己有一套分布式唯一ID生产方案。
自增ID：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能出现问题。
uuid：适合大量数据的插入和更新操作，但它是无序的，插入数据效率慢，占用空间大。


MySQL数据库cpu飙升的话，要怎么处理呢？
排查过程：
使用top命令观察，确定是mysqld导致还是其他原因。
如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。
找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。
处理：
kill掉这些线程(同时观察cpu使用率是否下降)，
进行相应的调整(比如说加索引、改sql、改内存参数)
重新跑SQL。
其他情况：
也有可能是每个sql消耗资源并不多，但是突然之间，有大量的session 连进来导致cpu飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

什么是存储过程？有哪些优缺点？
存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。
优点：
存储过程是一个预编译的代码块，执行效率比较高，存储过程在服务器端运行，减少客户端的压力，允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用，一个存储过程替代大量SQL语句 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。
缺点：
调试麻烦，可移植性不灵活，存在重新编译问题

了解什么是表分区吗？表分区的好处有哪些？
表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。
存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据。
优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。
分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。
避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问。

MySQL主从同步原理
MySQL的主从复制中主要有三个线程： master（binlog dump thread）、slave（I/O thread 、SQLthread） ，Master一条线程和Slave中的两条线程。
主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服
务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。
主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。
从节点 I/O线程接收 binlog 内容，并将其写入到 relay log 文件中。
从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。
注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。
由于MySQL默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。
全同步复制
主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
半同步复制
和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。

MyISAM和InnoDB的区别
MyISAM：
1、不支持事务，但是每次查询都是原子的；
2、支持表级锁，即每次操作是对整个表加锁；
3、存储表的总行数；
4、一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
5、采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

InnoDB：
1、支持ACID的事务，支持事务的四种隔离级别；
2、支持行级锁及外键约束：因此可以支持写并发；
3、不存储总行数；
4、一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
5、主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引树；索引最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。

简述MySQL中索引类型及对数据库的性能的影响
普通索引：允许被索引的数据列包含重复的值。
唯一索引：可以保证数据记录的唯一性
主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。
联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。
全文索引：通过建立 倒排索引 ,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table\_name ADD FULLTEXT (column);创建全文索引索引可以极大的提高数据的查询速度。


MySQL常见优化手段
（1）尽量选择较小的列
（2）将where中用的比较频繁的字段建立索引
（3）select子句中避免使用‘ \*’
（4）避免在索引列上使用计算、not in 和<>等操作
（5）当只需要一行数据的时候使用limit 1
（6）保证单表数据不超过200W，适时分割表。针对查询较慢的语句，可以使用explain 来分析该语句具体的执行情况。
（7）避免改变索引列的类型。
（8）选择最有效的表名顺序，from字句中写在最后的表是基础表，将被最先处理，在from子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。
（9）避免在索引列上面进行计算。
（10）能用关联查询的不要用子查询
（11）尽量缩小子查询的结果